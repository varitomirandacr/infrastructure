using Infrastructure.Creational.Builder;
using Infrastructure.Creational.Factory;
using Infrastructure.Creational.Prototype;
using Infrastructure.Creational.Singleton;
using Infrastructure.Structural;
using Infrastructure.Structural.Adapter;
using Infrastructure.Structural.Bridge;
using System;

namespace Infrastructure
{
    class Program
    {
        static void Main(string[] args)
        {
            // Creational
            // ApplyFactory.Apply();
            // ApplyBuilder.Apply();
            // ApplyPrototype.Apply();
            // ApplySingleton.Apply();

            // Structural
            // ApplyAdapter.Apply();
            ApplyBridge.Apply();
        }
    }

    // Creational
    public class ApplyFactory
    {
        public static void Apply()
        {
            Console.WriteLine("Applying Factory Pattern");
            Console.WriteLine("");

            ChildFactory factory = new ConcreteChildFactory();

            IFactory childOne = factory.GetChild("one");
            childOne.Do("child one created");

            IFactory childTwo = factory.GetChild("two");
            childTwo.Do("child two created");

            Console.WriteLine("");
            Console.WriteLine(ToString());

            Console.ReadKey();
        }

        public static new string ToString()
        {
            string toString = @"
////////////////////////////////////////////////////////////////////////////////////////////
It is good idea to use factory methods inside object when:
1. Object's class doesn't know what exact sub-classes it have to create
2. Object's class is designed so that objects it creates were specified by sub-classes
3. Object's class delegates its duties to auxiliary sub-classes and doesn't know what 
    exact class will take these duties

It is good idea to use abstract factory class when:
1. Your object shouldn't depend on how its inner objects are created and designed
2. Group of linked objects should be used together and you need to serve this constraint
3. Object should be configured by one of several possible families of linked objects that 
    will be a part of your parent object
4. It is required to share child objects showing interfaces only but not an implementation

Other Reasons:
1. A class (creator) will not know what classes it will be required to create
2. The process of objects created is required to centralize within the application
3. Parent class allows later instantiation to subclasses means the creation of an object is 
done when it is required
4. Subclasses figure out what objects should be created";

            return toString;
        }
    }

    public class ApplyBuilder
    {
        public static void Apply()
        {
            Console.WriteLine("Applying Builder Pattern");
            Console.WriteLine("");

            StepCreator creator = new StepCreator(new StepBuilder());
            creator.CreateStep();

            Step step = creator.GetStep();
            step.ShowInfo();

            Console.WriteLine("");
            Console.WriteLine(ToString());

            Console.ReadKey();
        }

        public static new string ToString()
        {
            string toString = @"
/////////////////////////////////////////////////////////////////////////////
Helps constructing complex objects step by step
Enforces a process to create an object as finished product
Encapsulates the logic to create complex object

Builder vs Factory: pretty similar but the builder is used 
when we need to do a los of steps to create/build an object

Product: complex object to be generated by the builder pattern
Builder: abstract base class defines the steps to be taken
ConcreteBuilder: N number of concrete builders that inherit from the builder
Director: creates the final product object";

            return toString;
        }
    }

    public class ApplyPrototype
    {
        public static void Apply()
        {
            Console.WriteLine("Applying Prototype Pattern");
            Console.WriteLine("");

            Child child = new Child();
            child.Id = 5;
            child.Name = "First";
            Console.WriteLine(child.GetDetails());

            Console.WriteLine("");
            Console.WriteLine("Shallow Copy using Prototype");
            Child shallow = (Child)child.ShallowCopy();
            shallow.Id = 6;
            Console.WriteLine(shallow.GetDetails());

            Console.WriteLine("");
            Console.WriteLine("Deep Clone using Prototype");
            Child deep = (Child)child.ShallowCopy();
            deep.Id = 7;
            Console.WriteLine(deep.GetDetails());

            Console.WriteLine("");
            Console.WriteLine(ToString());

            Console.ReadKey();
        }

        public static new string ToString()
        {
            string toString = @"
/////////////////////////////////////////////////////////////////////////////
The creation of each object is costly or complex
Limited number of state combinations exist in an object";

            return toString;
        }
    }

    public class ApplySingleton
    {
        public static void Apply()
        {
            Console.WriteLine("Applying Singleton Pattern");
            Console.WriteLine("");

            LoadBalancer b1 = LoadBalancer.GetLoadBalancer();
            LoadBalancer b2 = LoadBalancer.GetLoadBalancer();
            LoadBalancer b3 = LoadBalancer.GetLoadBalancer();
            LoadBalancer b4 = LoadBalancer.GetLoadBalancer();

            // Same instance?
            if (b1 == b2 && b2 == b3 && b3 == b4)            
                Console.WriteLine("Same instance\n");
           
            // Load balance 15 server requests
            LoadBalancer balancer = LoadBalancer.GetLoadBalancer();
            for (int i = 0; i < 15; i++)
            {
                string server = balancer.Server;
                Console.WriteLine("Next server dispatched: " + server.ToString());
            }

            Console.WriteLine("");
            Console.WriteLine(ToString());

            Console.ReadKey();
        }

        public static new string ToString()
        {
            string toString = @"
/////////////////////////////////////////////////////////////////////////////
Managing access to a resource which is shared by the entire application
- Logging class (does not affect execution of code)
- Load Balancer
- HttpConnections (you don't want a million http clients)
- Printer spooler
- Excel generation class
- Configuration files, that should be read at startup
- Database connection
- File manager
- Retrieve and store informations of external config files

A Singleton candidate must satisfy three requirements:
* controls concurrent access to a shared resource.
* access to the resource will be requested from multiple, disparate parts of the system.
* there can be only one object.";

            return toString;
        }
    }

    // Structural
    public class ApplyAdapter
    {
        public static void Apply()
        {
            Console.WriteLine("Applying Adapter Pattern");
            Console.WriteLine("");

            ITarget target = new Adapter(new Adaptee());
            Console.WriteLine(target.ExecuteRequest());

            Console.WriteLine("");
            Console.WriteLine(ToString());

            Console.ReadKey();
        }

        public static new string ToString()
        {
            string toString = @"
////////////////////////////////////////////////////////////////////////////////////////////
- Used on legacy code
- Adapter is recognizable by a constructor which takes an instance of 
different abstract/interface type
- Adapter lets classes work together that couldn't otherwise because of 
incompatible interfaces";

            return toString;
        }
    }

    public class ApplyBridge
    {
        public static void Apply()
        {
            Console.WriteLine("Applying Bridge Pattern");
            Console.WriteLine("");

            Bridge client = new Bridge(new ConcreteImplementationA());
            Console.WriteLine(client.Operation());

            Console.WriteLine("");

            Bridge extended = new ExtendedBridge(new ConcreteImplementationB());
            Console.WriteLine(extended.Operation());
                        
            Console.WriteLine("");
            Console.WriteLine(ToString());

            Console.ReadKey();
        }

        public static new string ToString()
        {
            string toString = @"
////////////////////////////////////////////////////////////////////////////////////////////
- Used on legacy code
- Adapter is recognizable by a constructor which takes an instance of 
different abstract/interface type
- Adapter lets classes work together that couldn't otherwise because of 
incompatible interfaces";

            return toString;
        }
    }
}
